"----------------------------------------------------------------------------------------------
"                                        _
"                                 _   __(_)___ ___  __________
"                                | | / / / __ `__ \/ ___/ ___/
"                                | |/ / / / / / / / /  / /__
"                                |___/_/_/ /_/ /_/_/   \___/
"
"                                 github.com/creasty/dotfiles
"
"----------------------------------------------------------------------------------------------

"=== Environment
"==============================================================================================
" encoding
set encoding=utf-8
scriptencoding utf-8

" disable default plugins
let g:loaded_gzip              = 1
let g:loaded_tar               = 1
let g:loaded_tarPlugin         = 1
let g:loaded_zip               = 1
let g:loaded_zipPlugin         = 1
let g:loaded_rrhelper          = 1
let g:loaded_2html_plugin      = 1
let g:loaded_vimball           = 1
let g:loaded_vimballPlugin     = 1
let g:loaded_getscript         = 1
let g:loaded_getscriptPlugin   = 1
let g:loaded_netrw             = 1
let g:loaded_netrwPlugin       = 1
let g:loaded_netrwSettings     = 1
let g:loaded_netrwFileHandlers = 1
let g:loaded_LogiPat           = 1
let g:loaded_logipat           = 1
let g:loaded_tutor_mode_plugin = 1
let g:loaded_man               = 1

" runtime plugins
let g:omni_sql_no_default_maps = 1
let g:tex_flavor = 'latex'

" s:env
function! s:vimrc_environment()
  let env = {}

  let env.is_starting = has('vim_starting')
  let env.is_gui = has('gui_running')

  let env.hostname = substitute(hostname(), '[^\w.]', '', '')

  let env.sid = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_vimrc_environment$')

  let dotfiles_path = $HOME . '/dotfiles'
  let vim_path = dotfiles_path . '/vim'

  let env.path = {
    \ 'dotfiles':       dotfiles_path,
    \ 'dein':           vim_path . '/dein',
    \ 'dein_repo':      vim_path . '/dein/repos/github.com/Shougo/dein.vim',
    \ 'dein_toml':      vim_path . '/dein.toml',
    \ 'dein_lazy_toml': vim_path . '/dein_lazy.toml',
    \ 'local':          vim_path . '/locals',
    \ 'dict':           vim_path . '/dict',
    \ 'template':       vim_path . '/templates',
    \ 'snippets':       vim_path . '/snippets',
  \ }

  let env.support = {
    \ 'ag':        executable('ag'),
    \ 'identify':  executable('identify'),
    \ 'osascript': executable('osascript'),
    \ 'autochdir': exists('+autochdir'),
  \ }

  return env
endfunction

let s:env = s:vimrc_environment()

function! s:with_snr(name)
  return '<SNR>' . s:env.sid . '_' . a:name
endfunction

" unregister autocmds
augroup vimrc
  autocmd!
augroup END


"=== Load hooks
"==============================================================================================
autocmd vimrc User VimrcHookPre call <SID>load_local_vimrc('pre')
autocmd vimrc User VimrcHookPostPlugin call <SID>load_local_vimrc('post_plugin')
autocmd vimrc User VimrcHookPost call <SID>load_local_vimrc('post')

function! s:load_local_vimrc(hook)
  let file = s:env.path.local . '/' . s:env.hostname . '.' . a:hook . '.vim'

  if filereadable(file)
    execute 'source ' . file
  endif
endfunction

doautocmd User VimrcHookPre


"=== Plugins
"==============================================================================================
if &compatible
  set nocompatible
endif

if s:env.is_starting
  let &g:rtp .= ',' . s:env.path.dein_repo
endif

let g:dein#_plugins = {}

if dein#load_state(s:env.path.dein)
  call dein#begin(s:env.path.dein, [expand('<sfile>'), s:env.path.dein_toml, s:env.path.dein_lazy_toml])

  call dein#load_toml(s:env.path.dein_toml,      { 'lazy': 0 })
  call dein#load_toml(s:env.path.dein_lazy_toml, { 'lazy': 1 })

  call dein#end()
  call dein#save_state()
endif

if dein#check_install()
  call dein#install()
endif

filetype plugin indent on

doautocmd User VimrcHookPostPlugin


"=== Encoding
"==============================================================================================
set encoding=utf-8
set fileencodings=ucs_bom,utf8,ucs-2le,ucs-2
set fileformats=unix,dos,mac

" auto detection
if &encoding !=# 'utf-8'
  set encoding=japan
  set fileencoding=japan
endif

if has('iconv')
  let s:enc_euc = 'euc-jp'
  let s:enc_jis = 'iso-2022-jp'

  if iconv("\x87\x64\x87\x6a", 'cp932', 'eucjp-ms') ==# "\xad\xc5\xad\xcb"
    let s:enc_euc = 'eucjp-ms'
    let s:enc_jis = 'iso-2022-jp-3'
  elseif iconv("\x87\x64\x87\x6a", 'cp932', 'euc-jisx0213') ==# "\xad\xc5\xad\xcb"
    let s:enc_euc = 'euc-jisx0213'
    let s:enc_jis = 'iso-2022-jp-3'
  endif

  if &encoding ==# 'utf-8'
    let s:fileencodings_default = &fileencodings
    let &fileencodings = s:enc_jis .','. s:enc_euc .',cp932'
    let &fileencodings = s:fileencodings_default .','. &fileencodings
    unlet s:fileencodings_default
  else
    let &fileencodings = &fileencodings .','. s:enc_jis
    set fileencodings+=utf-8,ucs-2le,ucs-2
    if &encoding =~# '^\(euc-jp\|euc-jisx0213\|eucjp-ms\)$'
      set fileencodings+=cp932
      set fileencodings-=euc-jp
      set fileencodings-=euc-jisx0213
      set fileencodings-=eucjp-ms
      let &encoding = s:enc_euc
      let &fileencoding = s:enc_euc
    else
      let &fileencodings = &fileencodings .','. s:enc_euc
    endif
  endif

  unlet s:enc_euc
  unlet s:enc_jis
endif

" force &fileencoding to use &encoding
" when files not contain japanese charactors
augroup AutoDetectEncording
  autocmd!
  autocmd BufReadPost *
    \ if &fileencoding =~# 'iso-2022-jp' && search("[^\x01-\x7e]", 'n') == 0 |
      \ let &fileencoding = &encoding |
    \ endif
augroup END


"=== Basics
"==============================================================================================
" change cursor shape in iTerm
if !s:env.is_gui && exists('$ITERM_PROFILE')
  if exists('$TMUX')
    let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
    let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
  else
    let &t_SI = "\<Esc>]50;CursorShape=1\x7"
    let &t_EI = "\<Esc>]50;CursorShape=0\x7"
  endif
endif

" use comma as leader
let mapleader = ','

" split to right / bottom
set splitright
set splitbelow

" use double width to print non-ascii charactors
set ambiwidth=double

" line offset when scrolling
set scrolloff=5

" no auto line breaking
set textwidth=0

" no backup and swap files
set nobackup
set noswapfile

" reload when files modified outside of vim
set autoread

" delete over lines and indents
set backspace=indent,eol,start

" add multibyte option
set formatoptions& formatoptions+=lmoq

" no beeps
set vb t_vb=

" initial dir of explorer
set browsedir=buffer

" move cursor over lines
set whichwrap=b,s,h,l,<,>,[,]

" display commands in statusline
set showcmd

" unnecessary, use lightline
set noshowmode

" config viminfo
" remember marks for last 50 files
" contents of register up to 100 lines each
" skip register with more than 100 kbytes
set viminfo='50,<1000,s100

" disable mode lines
set modelines=0

" command line completion
set wildmenu
set wildmode=list:full

" fast terminal connection
set ttyfast

" command history
set history=1000

" use dictionaries for completion
set complete=k

" yank use system clipboard
set clipboard=unnamed

" inc/decrement
set nf=alpha,hex

" disable IME
set imdisable

" nohidden buffers
set nohidden

" use Blowfish algorithm
set cryptmethod=blowfish

" wildcard settings
set suffixes=.bak,~,.swp,.o,.info,.aux,.log,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc
set wildignore& wildignore+=*.so,*.swp

" nice window title
set title titlestring=%{MyTitleText()}

function! MyTitleText()
  let t = []

  if !empty(v:servername)
    let name = substitute(v:servername, 'VIM', '', '')
    if name == ''
      let name = '0'
    endif
    call add(t, '$' . name . ':')
  endif

  let session = fnamemodify(v:this_session, ':t:r')

  if session != ''
    call add(t, '[' . session . ']')
  endif

  let path = expand('%:p')
  let path = (path != '') ? path : getcwd()
  let path = substitute(path, $HOME, '~', '')
  let path = substitute(path, '\~/go/src/github.com', '~g', '')
  call add(t, path)

  return join(t, ' ')
endfunction

" find file with suffixes
set suffixesadd& suffixesadd+=.js,.coffee,.swift,.scss

" fast update
set updatetime=200


"=== Apperance
"==============================================================================================
" syntax highlight & color scheme
set background=dark
set t_Co=256
syntax enable

if dein#tap('candle.vim')
  colorscheme candle
endif

" always show statusline
set laststatus=2

" always show tabline
set showtabline=2

" match pairs
set showmatch

" show line numbers
set number

" highlighting current line will slow down vim
set nocursorline

" do not redraw during command
set lazyredraw

" limit syntax highlighting
set synmaxcol=512

" display very very long line at the end of file
set display& display+=lastline

" display nonprintable charactors as hex
set display+=uhex

" show hidden charactors
set list
set listchars=tab:▸\ ,nbsp:∘,extends:❯,precedes:❮

" indent wrapped lines
if has('linebreak')
  set breakindent
  let &showbreak = '∙∙∙∙'
else
  let &showbreak = '❮'
end

" conceal
if has('conceal')
  set conceallevel=2 concealcursor=
endif

" color column
set colorcolumn=90
hi ColorColumn guibg=#1f1f1f ctermbg=234


"  Folding
"-----------------------------------------------
set foldmethod=indent
set fillchars="fold:"
set foldlevel=20
set foldlevelstart=20
set foldtext=CustomFoldText()

function! CustomFoldText()
  let fs = v:foldstart

  while getline(fs) =~ '^\s*$' | let fs = nextnonblank(fs + 1)
  endwhile

  if fs > v:foldend
    let line = getline(v:foldstart)
  else
    let line = substitute(getline(fs), '\t', repeat(' ', &tabstop), 'g')
  endif

  let w = winwidth(0) - &foldcolumn - (&number ? 8 : 0)

  let lineCounter = ' (' . (1 + v:foldend - v:foldstart) . ')'
  let expansion = repeat(' ', w - strwidth(lineCounter . line))

  return line . expansion . lineCounter
endfunction


"  Custom highlight
"-----------------------------------------------
if dein#tap('candle.vim')
  " highlight full-width space
  call candle#highlight('ZenkakuSpace', '', 'dark_red', '')
  autocmd vimrc BufWinEnter,WinEnter *
    \ call matchadd('ZenkakuSpace', '　')

  " highlight trailing spaces
  call candle#highlight('TrailingSpace', '', 'line', '')
  autocmd vimrc BufWinEnter,WinEnter *
    \ call matchadd('TrailingSpace', '\s\+$')
endif


"  Sign column
"-----------------------------------------------
" make sign column always visible
sign define mydummy

autocmd vimrc BufEnter * call <SID>add_dummy_sign()

function! s:add_dummy_sign()
  let bufnr = bufnr('')

  if !getbufvar(bufnr, 'my_dummy_sign')
    exec 'sign place 9999 line=1 name=mydummy buffer=' . bufnr
    call setbufvar(bufnr, 'my_dummy_sign', 1)
  endif
endfunction


"  Tabline
"-----------------------------------------------
function! MyTabLine()
  let s = ''
  let current = tabpagenr()

  for i in range(tabpagenr('$'))
    let tabnr = i + 1 " range() starts at 0
    let winnr = tabpagewinnr(tabnr)
    let buflist = tabpagebuflist(tabnr)
    let bufnr = buflist[winnr - 1]
    let bufname = fnamemodify(bufname(bufnr), ':t')

    let s .= '%' . tabnr . 'T'
    let s .= (tabnr == current ? '%#TabLineNrSel#' : '%#TabLineNr#')
    let s .= ' ' . tabnr
    let s .= '%#TabLineFill#'
    let s .= (tabnr == current ? '%#TabLineSel#' : '%#TabLine#')

    let s .= empty(bufname) ? ' [No Name] ' : ' ' . bufname . ' '
    if getbufvar(bufnr, "&mod")
      let s .= '+ '
    endif
  endfor

  let s .= '%#TabLineFill#'

  return s
endfunction

if dein#tap('candle.vim')
  set tabline=%!MyTabLine()

  autocmd vimrc VimEnter,Syntax *
    \ call candle#highlight('TabLineNr', 'selection', 'window', '')
    \ | call candle#highlight('TabLineNrSel', 'comment', 'foreground', '')
endif


"  Statusline
"-----------------------------------------------
function! RefreshStatusline()
  let cw = winnr()

  if !dein#tap('candle.vim')
    return
  endif

  for nr in range(1, winnr('$'))
    call setwinvar(nr, '&statusline', '%!MyStatusLine(' . nr . ', ' . cw . ')')
  endfor
endfunction

autocmd vimrc VimEnter,WinEnter,BufWinEnter * call RefreshStatusline()

function! MyStatusLine(w, cw)
  let s = ''

  let bufnr = winbufnr(a:w)
  let _bufname = bufname(bufnr)
  let bufmodified = getbufvar(bufnr, '&mod')
  let active = (a:w == a:cw)
  let width = winwidth(a:w)
  let ft = getbufvar(bufnr, '&ft')
  let enough_width = (width > 70)

  let bufname =
    \ empty(_bufname) ? '[No Name]' :
    \ _bufname == '__Tagbar__' ? 'Tagbar' :
    \ _bufname =~ '__Gundo\|NERD_tree' || ft == 'nerdtree' ? 'File' :
    \ ft == 'unite' ? 'Unite' :
    \ ft == 'help' ? 'Help' :
    \ ''

  let is_file = empty(bufname)

  if is_file
    let bufname = fnamemodify(_bufname, ':t')
  endif

  " file name
  let s .= '%#StatusLineLeft' . (active ? 'Active' : '') . '# '

  if is_file
    let s .= '#' . bufnr
    let s .= ' '
  endif

  if active || !is_file
    let s .= bufname
  else
    let head = fnamemodify(_bufname, ':h:t')
    let s .= (empty(head) || head == '.' ? '' : head . '/') . bufname
  endif

  let flag = ''
  let flag .= getbufvar(bufnr, '&readonly') ? '!' : ''
  let flag .= getbufvar(bufnr, '&mod') ? '+' : ''

  if !empty(flag)
    let s .= ' ' . flag
  endif

  let s .= ' %#StatusLine#'

  if active && ft == 'unite'
    let s .= ' ' . unite#get_status_string()
  endif

  " space
  let s .= '%='

  if active && enough_width
    " file type & encoding
    let s .= ' ' . (ft == '' ? 'plain' : ft) . ' ∙ ' . (empty(&fenc) ? 'utf-8' : &fenc) . ' '

    " cursor
    let s .= '%#StatusLineRight' . (active ? 'Active' : '') . '# '
    let s .= '%l:%c ∙ %p%%'
    let s .= ' %#StatusLine#'
  endif

  return s
endfunction

if dein#tap('candle.vim')
  autocmd vimrc VimEnter,Syntax *
    \ call candle#highlight('StatusLineLeft', 'selection', 'window', '')
    \ | call candle#highlight('StatusLineLeftActive', 'background', 'green', '')
    \ | call candle#highlight('StatusLineRight', 'background', 'selection', '')
    \ | call candle#highlight('StatusLineRightActive', 'window', 'foreground', '')

  let s:prev_status_line_mode = 'n'

  function! s:change_status_line_for_mode(m)
    if s:prev_status_line_mode == a:m
      return
    endif
    let s:prev_status_line_mode = a:m

    let color =
      \ a:m == 'i' ? 'blue' :
      \ a:m == 'v' ? 'orange' :
      \ a:m == 'r' ? 'purple' :
      \ 'green'

    call candle#highlight('StatusLineLeftActive', '', color, '')

    return ''
  endfunction

  autocmd vimrc InsertEnter,InsertChange * call <SID>change_status_line_for_mode(v:insertmode)
  autocmd vimrc InsertLeave,CursorHold * call <SID>change_status_line_for_mode(mode())

  nnoremap <expr> v <SID>change_status_line_for_mode('v') . 'v'
  nnoremap <expr> V <SID>change_status_line_for_mode('v') . 'V'
  nnoremap <expr> <C-v> <SID>change_status_line_for_mode('v') . "\<C-v>"
endif


"=== Search
"==============================================================================================
" cricle search within files
set wrapscan

" ignore case only if contains upper case
set ignorecase
set smartcase

" incremental search
set incsearch

" match highlight
set hlsearch

" make regex a little easier to type
" set magic

" dim match highlight
nnoremap <silent> <Space><Space> :nohlsearch<CR><Esc>

" erase previous match highlight
autocmd vimrc BufReadPost * :nohlsearch

" search selection
vnoremap <Space>/ "xy/<C-r>=escape(@x, '\\/.*$^~')<CR>

" replace selection
vnoremap <Space>r "xy:%s/<C-r>=escape(@x, '\\/.*$^~')<CR>/

" replace word under cursor
nnoremap <Space>* "xyiw:%s/\<<C-r>=escape(@x, '\\/.*$^~')<CR>\>/

" auto escaping
cnoremap <expr> /  getcmdtype() == '/' ? '\/' : '/'
cnoremap <expr> ?  getcmdtype() == '?' ? '\?' : '?'

" ag
if s:env.support.ag
  set grepprg=ag\ --nogroup\ -iS
  set grepformat=%f:%l:%m
endif


"=== Fast <C-o> hack
"==============================================================================================
function! s:insert_enter()
  set eventignore+=InsertLeave,InsertEnter
  return ''
endfunction

function! s:insert_leave()
  set eventignore-=InsertLeave,InsertEnter
  return "\<C-r>\<Esc>" | " Fix for missing screen update
endfunction

inoremap <expr> <Plug>(insert-enter) <SID>insert_enter()
inoremap <expr> <Plug>(insert-leave) <SID>insert_leave()


"=== Editing
"==============================================================================================
" indent
set noautoindent
set smartindent
set cindent
set smarttab
set expandtab
set tabstop=2 shiftwidth=2 softtabstop=0
set shiftround

" change soft-indent size
command! -nargs=1 SoftTab :setl expandtab tabstop=<args> shiftwidth=<args>

" virtualedit with freedom
set virtualedit& virtualedit+=block

" don't insert the current comment leader on leading lines
set formatoptions-=ro

" remove a comment leader when joining lines
if s:env.is_gui
  set formatoptions+=j
endif

" edit and apply vimrc
command! EditVimrc edit $MYVIMRC

" toggle paste mode
command! Pt :set paste!

" pay respect to vim
nnoremap <Up> <Nop>
nnoremap <Down> <Nop>
nnoremap <Left> <Nop>
nnoremap <Right> <Nop>

" move cursor visually with long lines
nmap j gj
vmap j gj
nmap k gk
vmap k gk

" Emacs-like key bindings
inoremap <Plug>(emacs-down) <C-g>u<C-o>gj
inoremap <Plug>(emacs-up) <C-g>u<C-o>gk
inoremap <Plug>(emacs-eol) <C-g>u<C-o>g$
inoremap <expr> <Plug>(emacs-bol) (col('.') == 2) ? "\<Left>" : "\<C-g>u\<C-o>g0"
inoremap <expr> <Plug>(emacs-kill) col('.') == col('$') ? "\<C-o>gJ" : "\<C-g>u\<C-o>d$"

map <C-c> <Esc>
imap <C-j> <CR>
inoremap <C-b> <Left>
inoremap <C-f> <Right>
inoremap <C-d> <Del>
imap <C-p> <Plug>(insert-enter)<Plug>(emacs-up)<Plug>(insert-leave)
imap <C-n> <Plug>(insert-enter)<Plug>(emacs-down)<Plug>(insert-leave)
imap <C-a> <Plug>(insert-enter)<Plug>(emacs-bol)<Plug>(insert-leave)
imap <C-e> <Plug>(insert-enter)<Plug>(emacs-eol)<Plug>(insert-leave)
imap <C-k> <Plug>(insert-enter)<Plug>(emacs-kill)<Plug>(insert-leave)

cnoremap <C-a> <Home>
cnoremap <C-b> <Left>
cnoremap <C-f> <Right>
cnoremap <C-d> <Del>
cnoremap <C-k> <C-\>e getcmdpos() == 1 ? '' : getcmdline()[:getcmdpos()-2]<CR>

" paste
inoremap <C-v> <C-r><C-p>*
cnoremap <C-v> <C-r>*

inoremap <C-\> <C-v>
cnoremap <C-\> <C-v>

" do not store to register with x, c
nnoremap x "_x
nnoremap X "_X
nnoremap c "_c
nnoremap C "_C
vnoremap c "_c
vnoremap x "_x

" undo
inoremap <C-u> <C-g>u<C-u>
inoremap <C-w> <C-g>u<C-w>

" why are you left out??
nnoremap Y y$

" keep the cursor in place while joining lines
nnoremap J mZJ`ZmZ

" split lines: inverse of J
nnoremap <silent> K ylpr<Enter>

" reselect visual block after indent/outdent
vnoremap < <gv
vnoremap > >gv

" indent/outdent
inoremap <C-s><C-h> <C-d>
inoremap <C-s><C-l> <C-t>
inoremap <C-s>h <C-d>
inoremap <C-s>l <C-t>

" easy key
nnoremap <Space>h g^
nnoremap <Space>l g$
nnoremap <Space>m %
vnoremap <Space>h g^
vnoremap <Space>l g$
vnoremap <Space>m %

" insert blank lines without going into insert mode
nnoremap <Space>o mZo<Esc>`ZmZ
nnoremap <Space>O mZO<Esc>`ZmZ

" reselect pasted text
nnoremap <expr> gp '`[' . strpart(getregtype(), 0, 1) . '`]'

" select all
map <Space>a ggVG

" repeat the last recorded macro
map Q @@

" avoid suicide
nnoremap ZQ <Nop>

" useless and annoying
vnoremap K <Nop>

" sort lines inside block
nnoremap <leader>sor ?{<CR>jV/\v^\s*\}?$<CR>k:sort<CR>:noh<CR>

" tags
nnoremap tn :tn<CR>
nnoremap tp :tp<CR>
nnoremap tl :tags<CR>

nnoremap <C-]> g<C-]>

" tab pages / buffers
nmap <C-w><C-t> <C-w>t
nnoremap <C-w>t :tabnew<CR>

nmap <C-w><C-v> <C-w>v
nnoremap <C-w>v :vnew<CR>

nmap <C-w><C-s> <C-w>s
nnoremap <C-w>s :split +enew<CR>

nmap <C-w><C-c> <Nop>
nnoremap <C-w>c <Nop>

nmap <C-w><C-d> <C-w>d
nnoremap <C-w>d :close<CR>

nnoremap <C-w><C-n> gt
nnoremap <C-w><C-b> gT

" tmux
nmap <C-s> <C-w>

" remove trailing spaces before saving
autocmd vimrc BufWritePre *
  \ if &ft != 'markdown' |
    \ :%s/\s\+$//ge |
  \ endif

" convert tabs to soft tabs if expandtab is set
autocmd vimrc BufWritePre *
  \ if &et |
    \ exec "%s/\t/" . repeat(' ', &tabstop) . "/ge" |
  \ endif

" back to the last line I edited
autocmd vimrc BufReadPost *
  \ if line("'\"") > 1 && line("'\"") <= line("$") |
    \ exe "normal! g`\"" |
  \ endif

" numbering selection in visual-block mode
nnoremap <silent> sc :ContinuousNumber <C-a><CR>
vnoremap <silent> sc :ContinuousNumber <C-a><CR>
command! -count -nargs=1 ContinuousNumber
  \ let c = col('.') |
  \ for n in range(1, <count>?<count>-line('.'):1) |
    \ exec 'normal! j' . n . <q-args> |
    \ call cursor('.', c) |
  \ endfor

" use I, A for all visual modes
vnoremap <expr> I <SID>force_blockwise_visual('I')
vnoremap <expr> A <SID>force_blockwise_visual('A')

function! s:force_blockwise_visual(next_key)
  let m = mode()

  if m == 'v'
    return "\<C-v>" . a:next_key
  elseif m == 'V'
    return "\<C-v>0o$" . a:next_key
  else
    return a:next_key
  endif
endfunction

" q:
nnoremap q: :q
nnoremap <Space>: q:


"=== Utils
"==============================================================================================
" reopen current buffer with specific encoding
command! -bang -nargs=? Utf8
  \ edit<bang> ++enc=utf-8 <args>
command! -bang -nargs=? Sjis
  \ edit<bang> ++enc=cp932 <args>
command! -bang -nargs=? Jis
  \ edit<bang> ++enc=iso-2022-jp <args>
command! -bang -nargs=? Euc
  \ edit<bang> ++enc=eucjp <args>

" clean up hidden buffers
command! CleanBuffers :call <SID>clean_buffers()

function! s:clean_buffers()
  redir => bufs
    silent buffers
  redir END

  for ibuf in split(bufs, "\n")
    let t = matchlist(ibuf, '\v^\s*(\d+)([^"]*)')
    if t[2] !~# '[#a+]'
      exec 'bdelete' t[1]
    endif
  endfor
endfunction

" create directories if not exist
autocmd vimrc BufWritePre *
 \ call s:auto_mkdir(expand('<afile>:p:h'))

function! s:auto_mkdir(dir)
  if !isdirectory(a:dir)
    call mkdir(iconv(a:dir, &encoding, &termencoding), 'p')
  endif
endfunction

" delete current file
function! s:delete_or_trash(file)
  let trash_dir = $HOME . '/.Trash'
  let file = fnameescape(a:file)

  if empty(file)
    return
  endif

  if isdirectory(trash_dir)
    call vimproc#system('mv ' . file . ' ' . trash_dir)
  else
    call delete(file)
  endif
endfunction

command! -nargs=0 Delete call <SID>delete_or_trash(expand('%:p')) | enew!

" rename current file name
command! -nargs=1 -complete=file Rename f <args> | w | call delete(expand('#'))

" edit a next file in the same directory
command! -nargs=0 NextFile call <SID>next_file(1)
command! -nargs=0 PrevFile call <SID>next_file(-1)

nnoremap g9 :PrevFile<CR>
nnoremap g0 :NextFile<CR>

function! s:next_file(direction)
  let path = expand('%:p')
  let directory = fnamemodify(path, ':h')

  let paths = split(globpath(directory, '*'), "\n")
  let files = filter(paths, '!isdirectory(v:val)')
  let n = len(files)
  let idx = index(files, path)

  if idx >= 0
    exec 'edit' fnameescape(files[(idx + a:direction) % n])
  endif
endfunction

" file detect on read / save
autocmd vimrc BufWritePost,BufReadPost,BufEnter *
  \ if &l:filetype ==# '' || exists('b:ftdetect') |
    \ unlet! b:ftdetect |
    \ filetype detect |
  \ endif

" automatically change input source
if s:env.support.osascript
  autocmd vimrc FocusGained *
    \ call vimproc#system("osascript -e 'tell application \"System Events\" to key code 102'")
endif

" inspect syntax
command! ScopeInfo echo map(synstack(line('.'), col('.')), 'synIDattr(synIDtrans(v:val), "name")')

" forcibly reload file
autocmd vimrc BufEnter * :checktime


"=== Auto save
"==============================================================================================
let g:auto_save = 1

autocmd User AutoSavePre :
autocmd User AutoSavePost :
autocmd vimrc CursorHoldI,CompleteDone * call <SID>auto_save()
autocmd vimrc CursorHold,InsertLeave * call <SID>auto_save()

command! AutoSaveToggle :call <SID>auto_save_toggle()

function! s:auto_save()
  if g:auto_save >= 1
    let was_modified = &modified

    doautocmd User AutoSavePre
    silent! wa

    if was_modified && !&modified
      let g:auto_save = 0
      try
        doautocmd User AutoSavePost
      finally
        let g:auto_save = 1
      endtry
      echo "(AutoSaved at " . strftime("%H:%M:%S") . ")"
    endif
  endif
endfunction

function! s:auto_save_toggle()
  if g:auto_save >= 1
    let g:auto_save = 0
    echo "AutoSave is OFF"
  else
    let g:auto_save = 1
    echo "AutoSave is ON"
  endif
endfunction


"=== Restore last closed buffers
"==============================================================================================
let g:lcb_max_restore_count = 5

let g:lcb_current = 0
let g:lcb_leaved  = 0
let g:lcb_closed  = []

function! s:lcb_remember_on_enter()
  let g:lcb_current = bufnr('')

  if g:lcb_leaved > 0 && !bufloaded(g:lcb_leaved)
    let g:lcb_closed = ([g:lcb_leaved] + g:lcb_closed)[0 : g:lcb_max_restore_count - 1]
  endif
endfunction

function! s:lcb_remember_on_leave()
  if g:lcb_current > 0 && !empty(bufname(g:lcb_current))
    let g:lcb_leaved = g:lcb_current
  endif
endfunction

function! s:lcb_restore()
  let nr = get(g:lcb_closed, 0, 0)
  let g:lcb_closed = g:lcb_closed[1:]

  if nr > 0 && bufexists(nr)
    exec 'buffer' nr
  endif
endfunction

autocmd vimrc BufEnter *
  \ call <SID>lcb_remember_on_enter()

autocmd vimrc BufLeave *
  \ call <SID>lcb_remember_on_leave()

nmap <C-w>r <C-w><C-r>
nnoremap <silent> <C-w><C-r> :call <SID>lcb_restore()<CR>


"=== Project root directory
"==============================================================================================
if s:env.support.autochdir
  set noautochdir
endif

let b:current_root_directory = '.'

let s:root_patterns = [
  \ '.git',
  \ '.git/',
  \ 'Rakefile',
  \ 'Gemfile',
  \ 'package.json',
  \ '.vimprojectroot',
  \ '*.xcodeproj',
  \ 'build.sbt',
\ ]

function! s:get_root_directory()
  let dir_current_file = fnameescape(expand('%:p:h'))

  for pattern in s:root_patterns
    if stridx(pattern, '/') != -1
      let match = finddir(pattern, dir_current_file . ';')

      if !empty(match)
        return fnamemodify(match, ':p:h:h')
      endif
    else
      let match = findfile(pattern, dir_current_file . ';')

      if !empty(match)
        return fnamemodify(match, ':p:h')
      endif
    endif
  endfor

  return ''
endfunction

function! s:can_change_directory()
  return match(expand('%:p'), '^\w\+://.*') == -1 && empty(&buftype)
endfunction

function! s:change_directory(dir)
  let edir = fnameescape(a:dir)

  exec 'setlocal path-=' . edir
  let b:current_root_directory = a:dir
  exec 'setlocal path+=' . edir

  exec 'lcd ' . edir
endfunction

function! s:change_to_root_directory()
  if !s:can_change_directory()
    return
  endif

  let dir = s:get_root_directory()

  if empty(dir)
    " change directory for non project files
    " let dir = expand('%:p:h')
    return
  endif

  call s:change_directory(dir)
endfunction

autocmd vimrc BufRead,BufEnter,WinEnter,TabEnter *
  \ call <SID>change_to_root_directory()


"=== Next/last text-object
"==============================================================================================
" dins  -- delete in next single quotes
"   foo = bar('spam')
"   C
"   foo = bar('')
"             C
" canp  -- change around next parens
"   foo = bar('spam')
"   C
"   foo = bar
"            C
" vind  -- select inside next double quotes
"   print "hello ", name
"    C
"   print "hello ", name
"          VVVVVV

onoremap <silent> an :<C-u>call <SID>next_text_object('a', '/')<CR>
xnoremap <silent> an :<C-u>call <SID>next_text_object('a', '/')<CR>
onoremap <silent> in :<C-u>call <SID>next_text_object('i', '/')<CR>
xnoremap <silent> in :<C-u>call <SID>next_text_object('i', '/')<CR>

onoremap <silent> al :<C-u>call <SID>next_text_object('a', '?')<CR>
xnoremap <silent> al :<C-u>call <SID>next_text_object('a', '?')<CR>
onoremap <silent> il :<C-u>call <SID>next_text_object('i', '?')<CR>
xnoremap <silent> il :<C-u>call <SID>next_text_object('i', '?')<CR>

function! s:next_text_object(motion, dir)
  let c = nr2char(getchar())
  let d = ''

  if c ==# "p" || c ==# "(" || c ==# ")"
    let c = "("
  elseif c ==# "b" || c ==# "{" || c ==# "}"
    let c = "{"
  elseif c ==# "r" || c ==# "[" || c ==# "]"
    let c = "["
  elseif c ==# 's' || c ==# "'"
    let c = "'"
  elseif c ==# 'd' || c ==# '"'
    let c = '"'
  else
    return
  endif

  " Find the next opening-whatever.
  execute "normal! " . a:dir . c . "\<cr>"

  if a:motion ==# 'a'
    " If we're doing an 'around' method, we just need to select around it
    " and we can bail out to Vim.
    execute "normal! va" . c
  else
    " Otherwise we're looking at an 'inside' motion.  Unfortunately these
    " get tricky when you're dealing with an empty set of delimiters because
    " Vim does the wrong thing when you say vi(.

    let open = ''
    let close = ''

    if c ==# "("
      let open = "("
      let close = ")"
    elseif c ==# "{"
      let open = "{"
      let close = "}"
    elseif c ==# "["
      let open = "\\["
      let close = "\\]"
    elseif c ==# "'"
      let open = "'"
      let close = "'"
    elseif c ==# '"'
      let open = '"'
      let close = '"'
    endif

    " We'll start at the current delimiter.
    let start_pos = getpos('.')
    let start_l = start_pos[1]
    let start_c = start_pos[2]

    " Then we'll find it's matching end delimiter.
    if c ==# "'" || c ==# '"'
      " searchpairpos() doesn't work for quotes, because fuck me.
      let end_pos = searchpos(open)
    else
      let end_pos = searchpairpos(open, '', close)
    endif

    let end_l = end_pos[0]
    let end_c = end_pos[1]

    call setpos('.', start_pos)

    if start_l == end_l && start_c == (end_c - 1)
      " We're in an empty set of delimiters.  We'll append an "x"
      " character and select that so most Vim commands will do something
      " sane.  v is gonna be weird, and so is y.  Oh well.
      execute "normal! ax\<esc>\<left>"
      execute "normal! vi" . c
    elseif start_l == end_l && start_c == (end_c - 2)
      " We're on a set of delimiters that contain a single, non-newline
      " character.  We can just select that and we're done.
      execute "normal! vi" . c
    else
      " Otherwise these delimiters contain something.  But we're still not
      " sure Vim's gonna work, because if they contain nothing but
      " newlines Vim still does the wrong thing.  So we'll manually select
      " the guts ourselves.
      let whichwrap = &whichwrap
      set whichwrap+=h,l

      execute "normal! va" . c . "hol"

      let &whichwrap = whichwrap
    endif
  endif
endfunction


"=== Number text-object
"==============================================================================================
" margin-top: 200px; -> dam -> margin-top: px;
" ^                                       ^
" TODO: Handle floats.

onoremap <silent> m  :<C-u>call <SID>number_text_object(0)<CR>
xnoremap <silent> m  :<C-u>call <SID>number_text_object(0)<CR>
onoremap <silent> am :<C-u>call <SID>number_text_object(1)<CR>
xnoremap <silent> am :<C-u>call <SID>number_text_object(1)<CR>
onoremap <silent> im :<C-u>call <SID>number_text_object(1)<CR>
xnoremap <silent> im :<C-u>call <SID>number_text_object(1)<CR>

function! s:number_text_object(whole)
  let num = '\v[0-9]'

  " If the current char isn't a number, walk forward.
  while getline('.')[col('.') - 1] !~# num
    normal! l
  endwhile

  " Now that we're on a number, start selecting it.
  normal! v

  " If the char after the cursor is a number, select it.
  while getline('.')[col('.')] =~# num
    normal! l
  endwhile

  " If we want an entire word, flip the select point and walk.
  if a:whole
    normal! o

    while col('.') > 1 && getline('.')[col('.') - 2] =~# num
      normal! h
    endwhile
  endif
endfunction


"=== Plugin: vim-textobj-multiblock
"==============================================================================================
if dein#tap('vim-textobj-multiblock')
  let g:textobj_multiblock_blocks = [
    \ [ '(', ')' ],
    \ [ '[', ']' ],
    \ [ '{', '}' ],
    \ [ '<', '>' ],
    \ [ '"', '"' ],
    \ [ "'", "'" ],
    \ [ '「', '」' ],
    \ [ '（', '）' ],
  \ ]

  omap ab <Plug>(textobj-multiblock-a)
  omap ib <Plug>(textobj-multiblock-i)
  xmap ab <Plug>(textobj-multiblock-a)
  xmap ib <Plug>(textobj-multiblock-i)
endif


"=== Plugin: surround.vim
"==============================================================================================
if dein#tap('surround.vim')
  nmap ,( csw(
  nmap ,) csw)
  nmap ,{ csw{
  nmap ,} csw}
  nmap ,[ csw[
  nmap ,] csw]
  nmap ,' csw'
  nmap ," csw"
endif


"=== Plugin: vim-easymotion
"==============================================================================================
if dein#tap('vim-easymotion')
  let g:EasyMotion_leader_key = '<Space>'
  let g:EasyMotion_keys = 'hjklasdfgyuiopqwertnmzxcvbHJKLASDFGYUIOPQWERTNMZXCVB'

  if dein#tap('candle.vim')
    call candle#highlight('EasyMotionTarget', 'yellow', 'dark_yellow', 'underline')
  endif
endif


"=== Plugin: nerdcommenter
"==============================================================================================
if dein#tap('nerdcommenter')
  nmap gcc <Leader>c<Space>
  vmap gcc <Leader>cm
  nmap gcs <Leader>cs
  vmap gcs <Leader>cs
  nmap gcy <Leader>cy
  vmap gcy <Leader>cy
  nmap gcI <Leader>c$
  vmap gcI <Leader>c$
  nmap gcA <Leader>cA
  vmap gcA <Leader>cA
endif


"=== Plugin: vim-easy-align
"==============================================================================================
if dein#tap('vim-easy-align')
  let g:easy_align_delimiters = {
    \ '=': {
      \ 'pattern':       '===\|<=>\|=\~[#?]\?\|=>\|[:+/*!%^=><&|.-?]*=[#?]\?'
      \                  . '\|[-=]>\|<[-=]',
      \ 'left_margin':   1,
      \ 'right_margin':  1,
      \ 'stick_to_left': 0,
    \ },
    \ ';': {
      \ 'pattern':       ':',
      \ 'left_margin':   0,
      \ 'right_margin':  1,
      \ 'stick_to_left': 1
    \ },
  \ }

  vnoremap <silent> L :EasyAlign<cr>
endif


"=== Plugin: emmet-vim
"==============================================================================================
if dein#tap('emmet-vim')
  let g:user_emmet_install_global = 0
  let g:user_emmet_mode = 'i'
  let g:user_emmet_leader_key = '<c-y>'
  let g:user_emmet_settings = {
    \ 'lang': 'ja',
    \ 'indentation': '  ',
  \ }
endif


"=== Plugin: operator-html-escape.vim
"==============================================================================================
if dein#tap('operator-camelize.vim')
  vmap C <Plug>(operator-camelize-toggle)
endif


"=== Plugin: vim-operator-replace
"==============================================================================================
if dein#tap('vim-operator-replace')
  map r <Plug>(operator-replace)
  noremap R r
endif


"=== Plugin: lexima.vim
"==============================================================================================
if dein#tap('lexima.vim')
  call lexima#set_default_rules()

  let indents = "^\(\t\|  \)\+"
  let opx     = "\(" . join(['[+-\*/%?]', '[&|<>]\{1,2}', '>>>'], '\|') . "\)"


  "  Disable lexima inside string literal
  "-----------------------------------------------
  function! s:disable_lexima_inside_string(char)
    call lexima#add_rule({
      \ 'char':  a:char,
      \ 'at':    '^\([^"]*"[^"]*"\)*[^"]*"[^"]*\%#',
      \ 'input': a:char,
    \ })
    call lexima#add_rule({
      \ 'char':  a:char,
      \ 'at':    '^\([^'']*''[^'']*''\)*[^'']*''[^'']*\%#',
      \ 'input': a:char,
    \ })
    call lexima#add_rule({
      \ 'char':  a:char,
      \ 'at':    '\%#',
      \ 'input': a:char,
      \ 'syntax': ['String'],
    \ })
  endfunction

  function! s:disable_lexima_inside_regexp(char)
    call lexima#add_rule({
      \ 'char':  a:char,
      \ 'at':    '\(...........\)\?/\S.*\%#.*\S/',
      \ 'input': a:char,
    \ })
  endfunction


  "  Quotes
  "-----------------------------------------------
  for quote in ['"', "'"]
    call lexima#add_rule({
      \ 'char':  quote,
      \ 'at':    '\(.......\)\?\%#\w',
      \ 'input': quote,
    \ })
    call lexima#add_rule({
      \ 'char':  quote,
      \ 'at':    '\(.......\)\?' . quote . '\%#',
      \ 'input': quote,
    \ })
    call lexima#add_rule({
      \ 'char':  quote,
      \ 'at':    '\(...........\)\?\%#' . quote,
      \ 'input': '<Right>',
    \ })

    call s:disable_lexima_inside_regexp(quote)
  endfor

  unlet quote


  "  Operators
  "-----------------------------------------------
  " looping with Smartchr
  let rules = {
    \ '<':     "smartchr#loop('<', '<<')",
    \ '>':     "smartchr#loop('>', '>>', '>>>')",
    \ '&':     "smartchr#loop('&', '&&')",
    \ '<Bar>': "smartchr#loop('|', '||')",
  \ }

  for [char, rule] in items(rules)
    let uchar = substitute(char, '<Bar>', '|', '')

    call lexima#add_rule({
      \ 'char':  char,
      \ 'at':    '\S\%#',
      \ 'input': ' ' . char . ' ',
    \ })
    call lexima#add_rule({
      \ 'char':  char,
      \ 'at':    '^\s*\%#',
      \ 'input': char . ' ',
    \ })
    call lexima#add_rule({
      \ 'char':  char,
      \ 'at':    '^\s*\%# ',
      \ 'input': char,
    \ })
    call lexima#add_rule({
      \ 'char':  char,
      \ 'at':    '\S \%#',
      \ 'input': char . ' ',
    \ })
    call lexima#add_rule({
      \ 'char':  char,
      \ 'at':    '\S \%# ',
      \ 'input': char,
    \ })
    call lexima#add_rule({
      \ 'char':  char,
      \ 'at':    '\(...\)\?' . uchar . ' \%#',
      \ 'input': '<BS><C-r>=' . rule . '<CR><Space>',
    \ })
    call lexima#add_rule({
      \ 'char':  char,
      \ 'at':    '\(...\)\?' . uchar . ' \%# ',
      \ 'input': '<BS><C-r>=' . rule . '<CR>',
    \ })

    call s:disable_lexima_inside_string(char)
    call s:disable_lexima_inside_regexp(char)
  endfor

  unlet char
  unlet uchar
  unlet rule
  unlet rules

  " space around
  for op in ['+', '-', '/', '*', '=', '%']
    let eop = escape(op, '*')

    call lexima#add_rule({
      \ 'char':  op,
      \ 'at':    '\w\%#',
      \ 'input': ' ' . op . ' ',
    \ })
    call lexima#add_rule({
      \ 'char':  op,
      \ 'at':    '\(^\|\w\) ' . eop . '\%#',
      \ 'input': op . ' ',
    \ })
    call lexima#add_rule({
      \ 'char':  op,
      \ 'at':    eop . ' \%#',
      \ 'input': '<BS>' . op . ' ',
    \ })

    call s:disable_lexima_inside_string(op)
    call s:disable_lexima_inside_regexp(op)
  endfor
  unlet op
  unlet eop

  " compound assignment operator
  call lexima#add_rule({
    \ 'char':  '=',
    \ 'at':    '\s[&|?+-/<>]\%#',
    \ 'input': '= ',
  \ })
  call lexima#add_rule({
    \ 'char':  '=',
    \ 'at':    '[&|?+-/<>] \%#',
    \ 'input': '<BS>= ',
  \ })

  " slash as non arithmetic operators
  call lexima#add_rule({
    \ 'char':  '/',
    \ 'at':    '\S/\S[^/]*\%#',
    \ 'input': '/',
  \ })
  call lexima#add_rule({
    \ 'char':  '/',
    \ 'at':    '^\s*\%#',
    \ 'input': '/',
  \ })
  call lexima#add_rule({
    \ 'char':  '/',
    \ 'at':    '^\s*/.*\%#',
    \ 'input': '/',
  \ })
  call s:disable_lexima_inside_regexp('/')

  " decrement/increment operators
  for op in ['+', '-']
    call lexima#add_rule({
      \ 'char':  op,
      \ 'at':    ' ' . op . ' \%#',
      \ 'input': '<BS><BS><BS>' . op . op,
    \ })
    call lexima#add_rule({
      \ 'char':  op,
      \ 'at':    indents . op . ' \%#',
      \ 'input': op,
    \ })
    call lexima#add_rule({
      \ 'char':  op,
      \ 'at':    '\w' . op . op . '\%#',
      \ 'input': '<BS><BS><Space>' . op . op . '<Space>',
    \ })
  endfor
  unlet op

  " dash in html/css
  call lexima#add_rule({
    \ 'char':     '-',
    \ 'at':       '\(........\)\?\%#',
    \ 'input':    '-',
    \ 'filetype': ['html', 'eruby', 'slim', 'xml', 'css', 'scss'],
  \ })
  call lexima#add_rule({
    \ 'char':     '-',
    \ 'at':       '^[ \t]*[\.#]\w\+\%#',
    \ 'input':    '-',
    \ 'filetype': ['haml', 'slim'],
  \ })
  call lexima#add_rule({
    \ 'char':     '-',
    \ 'at':       '}*[\.#]\w\+\%#',
    \ 'input':    '-',
    \ 'filetype': ['haml', 'slim'],
  \ })

  " hyphenated words
  call lexima#add_rule({
    \ 'char':  '-',
    \ 'at':    '\(........\)\?\w\+-\w\+\%#',
    \ 'input': '-',
  \ })


  "  C-l
  "-----------------------------------------------
  " nop
  call lexima#add_rule({
    \ 'char':  '<C-l>',
    \ 'at':    '\%#',
    \ 'input': '',
  \ })

  " transpose charactors before/after cursor
  call lexima#add_rule({
    \ 'char':  '<C-l>',
    \ 'at':    '\(...........\)\?\w\%#\w',
    \ 'input': '<Esc>"0ylxa<C-r>0<Left>',
  \ })

  " delete spaces around
  call lexima#add_rule({
    \ 'char':  '<C-l>',
    \ 'at':    '\S [+\-\*/%?&|<>=]\+ \%#',
    \ 'input': '<Esc>bh"_xf<Space>"_cl',
  \ })
  call lexima#add_rule({
    \ 'char':  '<C-l>',
    \ 'at':    '\S [+\-\*/%?&|<>=]\+\%#',
    \ 'input': '<Space><Esc>bh"_xf<Space>"_cl',
  \ })
  call lexima#add_rule({
    \ 'char':  '<C-l>',
    \ 'at':    '\S[+\-\*/%?&|<>=]\+ \%#',
    \ 'input': '<BS>',
  \ })

  " indent
  call lexima#add_rule({
    \ 'char':  '<C-l>',
    \ 'at':    '^\s*\%#',
    \ 'input': '<Esc>ddO',
  \ })

  " member access
  call lexima#add_rule({
    \ 'char':  '<C-l>',
    \ 'at':    '\w\(\.\|->\)\%#',
    \ 'input': "<C-r>=smartchr#loop('.', '->')<CR>",
  \ })

  " nesting
  for pa in ['()', '[]', '{}']
    call lexima#add_rule({
      \ 'char':  '<C-l>',
      \ 'at':    '\(...........\)\?' . escape(pa[1], '[]') . '\%#',
      \ 'input': '<Esc>%i' . pa[0] . '<Esc><Right>%a' . pa[1],
    \ })
    call lexima#add_rule({
      \ 'char':  '<C-l>',
      \ 'at':    '\(...........\)\?\%#' . escape(pa[1], '[]'),
      \ 'input': '<Esc><Right>%i' . pa[0] . '<Esc><Right>%i' . pa[1],
    \ })
  endfor
  unlet pa


  "  Backspace
  "-----------------------------------------------
  " delete whole pair
  for pa in ['()', '[]', '{}', '<>']
    let epa = escape(pa, '[]')

    call lexima#add_rule({
      \ 'char':  '<BS>',
      \ 'at':    epa[0] . '\s\+' . epa[1] . '\%#',
      \ 'input': '<C-o>di' . pa[0],
    \ })

    call lexima#add_rule({
      \ 'char':  '<BS>',
      \ 'at':    epa . '\%#',
      \ 'input': '<BS><BS>',
    \ })
  endfor

  unlet pa
  unlet epa


  "  Arrows
  "-----------------------------------------------
  for width in ['-', '=']
    " right-arrow
    call lexima#add_rule({
      \ 'char':  '<Tab>',
      \ 'at':    width . '\%#',
      \ 'input': '> ',
    \ })
    call lexima#add_rule({
      \ 'char':  '<Tab>',
      \ 'at':    '\S' . width . '\%#',
      \ 'input': '<BS> ' . width . '> ',
    \ })
    call lexima#add_rule({
      \ 'char':  '<Tab>',
      \ 'at':    width . ' \%#',
      \ 'input': '<BS>> ',
    \ })
    call lexima#add_rule({
      \ 'char':  '<Tab>',
      \ 'at':    width . '>\%#',
      \ 'input': '<BS><BS><' . width . ' ',
    \ })

    " left-arrow
    call lexima#add_rule({
      \ 'char':  '<Tab>',
      \ 'at':    '\(.....\)\?' . width . width . '\%#',
      \ 'input': '<BS><BS><' . width . ' ',
    \ })
    call lexima#add_rule({
      \ 'char':  '<Tab>',
      \ 'at':    '\S' . width . width . '\%#',
      \ 'input': '<BS><BS><BS> <' . width . ' ',
    \ })
    call lexima#add_rule({
      \ 'char':  '<Tab>',
      \ 'at':    width . width . ' \%#',
      \ 'input': '<BS><BS><BS><' . width . ' ',
    \ })

    " toggle
    call lexima#add_rule({
      \ 'char':  '<Tab>',
      \ 'at':    width . '> \%#',
      \ 'input': '<BS><BS><BS><' . width . ' ',
    \ })
    call lexima#add_rule({
      \ 'char':  '<Tab>',
      \ 'at':    '<' . width . '\%#',
      \ 'input': '<BS><BS>' . width . '> ',
    \ })
    call lexima#add_rule({
      \ 'char':  '<Tab>',
      \ 'at':    '<' . width . ' \%#',
      \ 'input': '<BS><BS><BS>' .  width . '> ',
    \ })
  endfor
  unlet width

  " indent on return
  call lexima#add_rule({
    \ 'char':  '<CR>',
    \ 'at':    '\(<[-=]\|[-=]>\)\%#',
    \ 'input': '<CR><Tab>',
  \ })
  call lexima#add_rule({
    \ 'char':  '<CR>',
    \ 'at':    '\(<[-=]\|[-=]>\) \%#',
    \ 'input': '<BS><CR><Tab>',
  \ })


  "  Fix pair completion
  "-----------------------------------------------
  for pair in ['()', '[]', '{}']
    call lexima#add_rule({
      \ 'char':  pair[0],
      \ 'at':    '\(........\)\?\%#[^\s' . escape(pair[1], ']') . ']',
      \ 'input': pair[0],
    \ })
  endfor
  unlet pair


  "  Comma
  "-----------------------------------------------
  call lexima#add_rule({
    \ 'char':     ',',
    \ 'at':       '\%#',
    \ 'input':    "<C-r>=smartchr#loop(', ', ',')<CR>",
  \ })


  "  C
  "-----------------------------------------------
  " include
  call lexima#add_rule({
    \ 'char':     '<Space>',
    \ 'at':       '^#include\%#',
    \ 'input':    ' <><Left>',
    \ 'filetype': ['c', 'cpp', 'objc'],
  \ })

  " member access on pointer `->`
  call lexima#add_rule({
    \ 'char':     ',',
    \ 'at':       '\(........\)\?\w\+[\.,]\%#',
    \ 'input':    '<BS>->',
    \ 'filetype': ['c', 'cpp', 'objc'],
  \ })
  for at in split('_abcdefghijklmnopqrstuvwxyz', '.\zs\ze.')
    call lexima#add_rule({
      \ 'char':     at,
      \ 'at':       '\(........\)\?\w\+\.\.\%#',
      \ 'input':    '<BS><BS>->' . at,
      \ 'filetype': ['c', 'cpp', 'objc'],
    \ })
  endfor
  unlet at


  "  Vim
  "-----------------------------------------------
  " end wise
  for at in ['fu', 'fun', 'func', 'funct', 'functi', 'functio', 'function', 'if', 'wh', 'whi', 'whil', 'while', 'for', 'try']
    call lexima#add_rule({
      \ 'char':     '<CR>',
      \ 'at':       '^\s*' . at . '\>.*\%#',
      \ 'input':    '<CR>end' . at . '<Esc>O',
      \ 'filetype': ['vim'],
    \ })
  endfor
  unlet at


  "  Ruby
  "-----------------------------------------------
  " end wise
  for at in [
      \ '\%([=,*/%+-]\|<<\|>>\|:\s\|^\)\s*\%(module\|def\|class\|if\|unless\|for\|while\|until\|case\)\>\%(.*[^.:@$]\<end\>\)\@!.*\%#',
      \ '^\s*\(public\|protected\|private\)\s\+def\>\%(.*[^.:@$]\<end\>\)\@!.*\%#',
      \ '^\s*\%(begin\)\s*\%#',
      \ '\%(^\s*#.*\)\@<!do\%(\s*|\k\+|\)\?\s*\%#',
    \ ]

    call lexima#add_rule({
      \ 'char':     '<CR>',
      \ 'at':       at,
      \ 'input':    '<CR>end<Esc>O',
      \ 'filetype': ['ruby'],
    \ })
  endfor
  unlet at

  call lexima#add_rule({
    \ 'char':     '<CR>',
    \ 'at':       '\<\%(if\|unless\)\>.*\%#',
    \ 'input':    '<CR>end<Esc>O',
    \ 'filetype': ['ruby'],
    \ 'syntax':   ['rubyConditionalExpression']
  \ })

  " block
  call lexima#add_rule({
    \ 'char':     '<Bar>',
    \ 'at':       '\({\|do\)\s*\%#',
    \ 'input':    '<Bar><Bar><Left>',
    \ 'filetype': ['ruby'],
  \ })
  call lexima#add_rule({
    \ 'char':     '<Bar>',
    \ 'at':       '\({\|do\)\s*|[^|]*\%#|',
    \ 'input':    '<Right>',
    \ 'filetype': ['ruby'],
  \ })

  " lambda
  call lexima#add_rule({
    \ 'char':     '(',
    \ 'at':       '\(........\)\?-> \%#',
    \ 'input':    '<BS>()<Left>',
    \ 'filetype': ['ruby'],
  \ })


  "  Shell
  "-----------------------------------------------
  " do-end pair
  let rules = {
    \ '^\s*if\>.*\%#':             'fi',
    \ '^\s*case\>.*\%#':           'esac',
    \ '\%(^\s*#.*\)\@<!do\>.*\%#': 'done',
  \ }

  for [at, end_word] in items(rules)
    call lexima#add_rule({
      \ 'char':     '<CR>',
      \ 'at':       at,
      \ 'input':    '<CR>' . end_word . '<Esc>O',
      \ 'filetype': ['sh', 'zsh'],
    \ })
  endfor

  unlet at
  unlet end_word
  unlet rules


  "  Html
  "-----------------------------------------------
  " tag
  call lexima#add_rule({
    \ 'char':  '>',
    \ 'at':    '\(.....\)\?<\%#',
    \ 'input': '>',
  \ })
  call lexima#add_rule({
    \ 'char':  '>',
    \ 'at':    '\(........\)\?< \%#',
    \ 'input': '<BS>><Left>',
  \ })
  call lexima#add_rule({
    \ 'char':  '>',
    \ 'at':    '\(........\)\?<\%#>',
    \ 'input': '<Right>',
  \ })
  call lexima#add_rule({
    \ 'char':     '<',
    \ 'at':       '\(........\)\?\%#',
    \ 'input':    '<><Left>',
    \ 'filetype': ['html', 'eruby', 'slim', 'php', 'xml'],
  \ })
  call lexima#add_rule({
    \ 'char':     '>',
    \ 'at':       '\(........\)\?\%#',
    \ 'input':    '>',
    \ 'filetype': ['html', 'eruby', 'slim', 'php', 'xml'],
  \ })
  call lexima#add_rule({
    \ 'char':     '>',
    \ 'at':       '\(........\)\?\%#>',
    \ 'input':    '<Right>',
    \ 'filetype': ['html', 'eruby', 'slim', 'php', 'xml'],
  \ })

  " attributes
  call lexima#add_rule({
    \ 'char':     '=',
    \ 'at':       '\(........\)\?<.\+\%#',
    \ 'input':    '=""<Left>',
    \ 'filetype': ['html', 'eruby', 'slim', 'php', 'xml'],
  \ })

  " closing tag
  call lexima#add_rule({
    \ 'char':     '/',
    \ 'at':       '\(........\)\?<\%#>',
    \ 'input':    '/<C-x><C-o><BS><ESC>a',
    \ 'filetype': ['html', 'eruby', 'slim', 'php', 'xml'],
  \ })

  " entity
  call lexima#add_rule({
    \ 'char':     '&',
    \ 'at':       '\(........\)\?\%#',
    \ 'input':    '&;<Left>',
    \ 'filetype': ['html', 'eruby', 'slim', 'php', 'xml'],
  \ })

  " comment
  call lexima#add_rule({
    \ 'char':     '-',
    \ 'at':       '\(........\)\?<\%#>',
    \ 'input':    '!--  --<Left><Left><Left>',
    \ 'filetype': ['html', 'eruby', 'slim', 'php', 'xml'],
  \ })

  " server script
  call lexima#add_rule({
    \ 'char':     '%',
    \ 'at':       '\(........\)\?<\%#',
    \ 'input':    '%  %<Left><Left>',
    \ 'filetype': ['html', 'ejs', 'eruby'],
  \ })
  call lexima#add_rule({
    \ 'char':     '%',
    \ 'at':       '\(........\)\?<%[=-]\? \%#',
    \ 'input':    "<C-r>=smartchr#loop('% ', '%= ', '%- ')<CR>",
    \ 'filetype': ['html', 'ejs', 'eruby'],
  \ })


  "  Haml / Slim
  "-----------------------------------------------
  " equal sign
  call lexima#add_rule({
    \ 'char':     '=',
    \ 'at':       '^\s*\([.#%]\(\w\|-\)\+\)*\%#',
    \ 'input':    '= ',
    \ 'filetype': ['haml', 'slim'],
  \ })


  "  PHP
  "-----------------------------------------------
  " <?php
  call lexima#add_rule({
    \ 'char':     '?',
    \ 'at':       '\(........\)\?<\%#>',
    \ 'input':    '?php  ?<Left><Left>',
    \ 'filetype': ['php'],
  \ })


  "  SQL
  "-----------------------------------------------
  " not <>
  call lexima#add_rule({
    \ 'char':     '>',
    \ 'at':       '\(.....\)\?< \%#',
    \ 'input':    '<BS>><Space>',
    \ 'filetype': ['sql'],
  \ })


  "  Go
  "-----------------------------------------------
  " chan
  call lexima#add_rule({
    \ 'char':     '<C-l>',
    \ 'at':       '\(chan\|<-chan\|chan<-\)\%#',
    \ 'input':    "<C-r>=smartchr#loop('chan', '<-chan', 'chan<-')<CR>",
    \ 'filetype': ['go'],
  \ })


  "  Markdown
  "-----------------------------------------------
  " horizontal rule
  call lexima#add_rule({
    \ 'char':     '-',
    \ 'at':       '^-\%#',
    \ 'input':    "<C-r>=repeat('-', 80)<CR>",
    \ 'filetype': ['markdown'],
  \ })

  " headering
  for d in ['-', '=']
    call lexima#add_rule({
      \ 'char':     d,
      \ 'at':       '^\n\%#',
      \ 'input':    d,
      \ 'filetype': ['markdown'],
    \ })
    call lexima#add_rule({
      \ 'char':     d,
      \ 'at':       '^\%#',
      \ 'input':    "<C-r>=MarkdownTitleLine('" . d . "')<CR>",
      \ 'filetype': ['markdown'],
    \ })
  endfor
  unlet d

  function! MarkdownTitleLine(char)
    let text = getline(line('.') - 1)

    if text =~ '^\(\t\|  \)*[-=]\s'
      return a:char . ' '
    else
      return repeat(a:char, strwidth(text))
    endif
  endfunction


  "  Command mode
  "-----------------------------------------------
  " write a file as sudo :w!!
  call lexima#add_rule({
    \ 'char':  '!',
    \ 'at':    '^w!\%#',
    \ 'input': "\<C-u>w !sudo tee % > /dev/null",
    \ 'mode':  ':',
  \ })

  " edit relative :ee
  call lexima#add_rule({
    \ 'char':  'e',
    \ 'at':    '^e\%#',
    \ 'input': " \<C-r>=expand('%:p:h') . '/' \<CR>",
    \ 'mode':  ':',
  \ })

  " directory shortcuts
  let directories = {
    \ 'h': '~/',
    \ 'g': '~/go/src/github.com/',
  \ }

  for [shortcut, directory] in items(directories)
    call lexima#add_rule({
      \ 'char':  shortcut,
      \ 'at':    '^e\%#',
      \ 'input': ' ' . directory,
      \ 'mode':  ':',
    \ })
  endfor
  unlet directories
  unlet shortcut
  unlet directory

  " edit buffer :eb
  call lexima#add_rule({
    \ 'char':  'b',
    \ 'at':    '^e\%#',
    \ 'input': ' #',
    \ 'mode':  ':',
  \ })

  " rename :er
  call lexima#add_rule({
    \ 'char':  'r',
    \ 'at':    '^e\%#',
    \ 'input': "\<C-u>Rename \<C-r>=expand('%:p') \<CR>",
    \ 'mode':  ':',
  \ })


  "  Super tab completion
  "-----------------------------------------------
  imap <silent> <expr> <Tab> SuperTabCompletion()

  function! SuperTabCompletion()
    if pumvisible()
      return "\<C-r>=neocomplete#close_popup()\<CR>"  " \<C-y> is buggy
    elseif neosnippet#expandable_or_jumpable()
      return "\<C-g>u" . neosnippet#mappings#expand_or_jump_impl()
    elseif &ft =~ 'x\?html\|xml\|haml\|slim\|s\?css\|markdown' && emmet#isExpandable()
      return "\<C-g>u\<C-r>=emmet#expandAbbr(0, '')\<CR>"
    else
      return "\<C-r>=lexima#expand('<TAB>', 'i')\<CR>"
    endif
  endfunction
endif


"=== Plugin: switch.vim
"==============================================================================================
if dein#tap('switch.vim')
  let g:switch_custom_definitions = [
    \ {
      \ '''\(.\{-}\)''': '"\1"',
      \ '"\(.\{-}\)"':   '''\1''',
      \ ':\(\w\+\)':     '''\1''',
    \ },
    \ {
      \ '\<public\>': 'protected',
      \ '\<protected\>': 'private',
      \ '\<private\>': 'public',
    \ },
    \ {
      \ '\<\(it\|describe\|context\|senario\)\>': 'x\1',
      \ '\<x\(it\|describe\|context\|senario\)\>': '\1',
    \ },
    \ {
      \ '\<and\>': 'or',
      \ '\<or\>': 'and',
    \ },
    \ {
      \ '\<if\>': 'unless',
      \ '\<unless\>': 'if',
    \ },
    \ {
      \ '\<true\>': 'false',
      \ '\<false\>': 'true',
    \ },
    \ {
      \ '\<TRUE\>': 'FALSE',
      \ '\<FALSE\>': 'TRUE',
    \ },
    \ {
      \ '\<on\>': 'off',
      \ '\<off\>': 'on',
    \ },
    \ {
      \ '\<ON\>': 'OFF',
      \ '\<OFF\>': 'ON',
    \ },
    \ {
      \ '\<yes\>': 'no',
      \ '\<no\>': 'yes',
    \ },
    \ {
      \ '\<YES\>': 'NO',
      \ '\<NO\>': 'YES',
    \ },
  \ ]

  nnoremap <silent> - :Switch<CR>
endif


"=== Plugin: vim-textmanip
"==============================================================================================
if dein#tap('vim-textmanip')
  let g:textmanip_enable_mappings = 0

  " move selection
  vmap <C-j> <Plug>(textmanip-move-down)
  vmap <C-k> <Plug>(textmanip-move-up)
  vmap <C-h> <Plug>(textmanip-move-left)
  vmap <C-l> <Plug>(textmanip-move-right)

  " duplicate line
  vmap <Space><C-j> <Plug>(textmanip-duplicate-down)
  vmap <Space><C-k> <Plug>(textmanip-duplicate-up)
  vmap <Space><C-h> <Plug>(textmanip-duplicate-left)
  vmap <Space><C-l> <Plug>(textmanip-duplicate-right)

  let g:textmanip_hooks = {}

  function! g:textmanip_hooks.finish(tm)
    let tm = a:tm
    let helper = textmanip#helper#get()
    if tm.linewise
      " if filetype is `html` automatically indent
      if &ft ==# 'html'
        call helper.indent(tm)
      endif
    else
      " When blockwise move/duplicate, remove trailing white space.
      " To use this feature without feeling counterintuitive,
      " I recommend you to ':set virtualedit=block',
      call helper.remove_trailing_WS(tm)
    endif
  endfunction
endif


"=== Plugin: mold.vim
"==============================================================================================
if dein#tap('mold.vim')
  " autocmd vimrc BufNewFile * call mold#load('', 1)

  autocmd vimrc User MoldTemplateLoadPre  call <SID>template_before_load()
  autocmd vimrc User MoldTemplateLoadPost call <SID>template_after_load()

  let s:mold_template_macro = {
    \ 'FILE_PATH': "\\=expand('%:p')",
    \ 'FILE_NAME': "\\=expand('%:t')",
    \ 'FULL_NAME': "Yuki Iwanaga",
    \ 'USER_NAME': "Creasty",
  \ }

  function! s:template_before_load()
    let b:mold_saved_cursor = getcurpos()
  endfunction

  function! s:template_after_load()
    for [macro, def] in items(s:mold_template_macro)
      silent exec '%s/\<' . macro . '\>/' . def . '/ge'
    endfor

    silent! :%!erb -T '-'

    if search('<+CURSOR+>')
      execute 'normal! "_da>'
    else
      call setpos('.', b:mold_saved_cursor)
    endif
  endfunction
endif


"=== Plugin: neocomplete.vim
"==============================================================================================
if dein#tap('neocomplete.vim')
  set completeopt& completeopt-=preview

  let g:neocomplete#enable_at_startup = 1
  let g:neocomplete#enable_smart_case = 1
  let g:neocomplete#disable_auto_complete = 0
  let g:neocomplete#enable_auto_select = 1
  let g:neocomplete#enable_insert_char_pre = 1
  let g:neocomplete#sources#syntax#min_keyword_length = 3
  let g:neocomplete#sources#buffer#disabled_pattern = '\.log\|\.log\.\|\.jax'
  let g:neocomplete#lock_buffer_name_pattern = '\.log\|\.log\.\|.*quickrun.*\|.jax'

  let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default':    '',
    \ 'vimshell':   $HOME . '/.vimshell_hist',
    \ 'ruby':       s:env.path.dict . '/ruby.dict',
    \ 'java':       s:env.path.dict . '/java.dict',
    \ 'javascript': s:env.path.dict . '/javascript.dict',
    \ 'coffee':     s:env.path.dict . '/javascript.dict',
    \ 'html':       s:env.path.dict . '/html.dict',
    \ 'php':        s:env.path.dict . '/php.dict',
    \ 'objc':       s:env.path.dict . '/objc.dict',
    \ 'swift':      s:env.path.dict . '/swift.dict',
    \ 'perl':       s:env.path.dict . '/perl.dict',
    \ 'scala':      s:env.path.dict . '/scala.dict',
  \ }

  " keyword patterns
  let g:neocomplete#keyword_patterns = get(g:, 'neocomplete#keyword_patterns', {})
  let g:neocomplete#keyword_patterns._ = '\h\w*'
  let g:neocomplete#keyword_patterns.perl = '\h\w*->\h\w*\|\h\w*::\w*'

  " input patterns
  let g:neocomplete#sources#omni#input_patterns = get(g:, 'neocomplete#sources#omni#input_patterns', {})
  let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
  let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
  let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
  let g:neocomplete#sources#omni#input_patterns.go = '[^.[:digit:] *\t]\.\%(\w\|\/\)*'
  let g:neocomplete#sources#omni#input_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'
  let g:neocomplete#sources#omni#input_patterns.typescript = '\h\w*\|[^. \t]\.\w*'

  " omni
  let g:neocomplete#force_overwrite_completefunc = 1
  let g:neocomplete#force_omni_input_patterns = get(g:, 'neocomplete#force_omni_input_patterns', {})
  let g:neocomplete#force_omni_input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)\w*'
  let g:neocomplete#force_omni_input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*'
  let g:neocomplete#force_omni_input_patterns.objc = '[^.[:digit:] *\t]\%(\.\|->\)\w*'
  let g:neocomplete#force_omni_input_patterns.objcpp = '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*'

  " clang
  let g:clang_complete_auto = 0
  let g:clang_auto_select = 0
  let g:clang_use_library = 1

  " omni completion
  autocmd vimrc FileType css
    \ setlocal omnifunc=csscomplete#CompleteCSS
  autocmd vimrc FileType html,markdown
    \ setlocal omnifunc=htmlcomplete#CompleteTags
  autocmd vimrc FileType javascript
    \ setlocal omnifunc=javascriptcomplete#CompleteJS
  autocmd vimrc FileType python
    \ setlocal omnifunc=pythoncomplete#Complete
  autocmd vimrc FileType xml
    \ setlocal omnifunc=xmlcomplete#CompleteTags
  autocmd vimrc FileType go
    \ setlocal omnifunc=gocomplete#Complete
  autocmd vimrc FileType typescript
    \ setlocal omnifunc=TSScompleteFunc

  " cancel or accept
  imap <silent> <expr> <C-c> pumvisible() ? "\<C-r>=neocomplete#cancel_popup()\<CR>" : "\<Esc>"
  imap <silent> <expr> <C-j> pumvisible() ? "\<C-r>=neocomplete#close_popup()\<CR>" : "\<CR>"
endif


"=== Plugin: neosnippet
"==============================================================================================
if dein#tap('neosnippet')
  let g:neosnippet#disable_select_mode_mappings = 0
  let g:neosnippet#enable_snipmate_compatibility = 1
  let g:neosnippet#snippets_directory = s:env.path.snippets
  let g:neosnippet#disable_runtime_snippets = { '_' : 1 }

  " remove placeholders (hidden markers) before saving
  autocmd vimrc BufWritePre *
    \ exec '%s/<`\d\+:\?[^>]*`>//ge'
endif


"=== Plugin: nerdtree
"==============================================================================================
if dein#tap('nerdtree')
  let g:NERDSpaceDelims = 1
  let g:NERDShutUp = 1
  let g:NERDTreeShowHidden = 1
  let g:NERDTreeIgnore = ['\~$', '\.sass-cache$', '\.git$']
  let g:NERDTreeAutoDeleteBuffer = 1
endif


"=== Plugin: unite.vim
"==============================================================================================
if dein#tap('unite.vim')
  function! s:unite_on_source() abort
    let g:unite_force_overwrite_statusline = 0
    let g:unite_enable_start_insert = 1
    let g:unite_winheight = 10
    let g:unite_enable_ignore_case = 1
    let g:unite_enable_smart_case = 1
    let g:unite_source_rec_min_cache_files = 50
    let g:unite_source_rec_max_cache_files = 30000
    let g:unite_source_history_yank_enable = 1

    let ignore_globs = unite#sources#rec#define()[0]['ignore_globs'] + [
      \ '.tags',
      \ '*.jpg', '*.jpeg', '*.png', '*.gif', '*.pdf', '*.ttf', '*.otf', '*.eot', '*.woff', '*.svg', '*.svgz',
      \ 'tmp/**', 'cache/**', 'public/system/**', 'vendor/bundle/**',
      \ 'node_modules/**', 'bower_components/**',
      \ 'Godeps/**',
    \ ]

    call unite#custom#source(
      \ join([
        \ 'file',
        \ 'file_rec',
        \ 'file_rec/async',
        \ 'file_rec/git',
        \ 'grep',
      \ ], ','),
      \ 'ignore_globs',
      \ ignore_globs
    \ )

    call unite#custom#profile('source/grep', 'context', {
      \ 'no_quit':  1,
      \ 'no_empty': 1,
    \ })

    if s:env.support.ag
      let g:unite_source_grep_command       = 'ag'
      let g:unite_source_grep_default_opts  = '--nogroup --nocolor --column'
      let g:unite_source_grep_recursive_opt = ''
    endif

    autocmd vimrc FileType unite call s:unite_my_settings()

    function! s:unite_my_settings()
      let unite = unite#get_current_unite()

      call clearmatches()

      imap <buffer> <C-h> <BS>
      inoremap <buffer> <C-d> <Del>
      inoremap <buffer> <C-b> <Left>
      inoremap <buffer> <C-f> <Right>
      inoremap <buffer> <C-e> <End>

      nmap <buffer> <C-q> <Plug>(unite_exit)
      imap <buffer> <C-q> <Plug>(unite_exit)
      imap <buffer> <C-k> <Plug>(unite_delete_backward_line)
      imap <buffer> <C-a> <Plug>(unite_move_head)
      imap <buffer> <C-j> <Plug>(unite_do_default_action)
      imap <buffer> <C-l> <Plug>(unite_redraw)

      if unite.buffer_name =~# '^search'
        nnoremap <silent><buffer><expr> r unite#do_action('replace')
      else
        nnoremap <silent><buffer><expr> r unite#do_action('rename')
      endif
    endfunction

  endfunction

  function! s:dispatch_unite_file_rec_async_or_git()
    if getcwd() == $HOME
      Unite ghq
    elseif isdirectory(get(b:, 'current_root_directory', '.') . '/.git')
      Unite -hide-source-names -buffer-name=files file_rec/git
    else
      Unite -hide-source-names -buffer-name=files file_rec/async
    endif
  endfunction

  nnoremap <silent> <C-q> :<C-u>call <SID>dispatch_unite_file_rec_async_or_git()<CR>
  nnoremap <silent> <Space><C-q>a :Unite -hide-source-names -buffer-name=files file_rec/async<CR>
  nnoremap <silent> <Space>p :Unite -hide-source-names history/yank<CR>
  imap <silent> <C-x><C-v> <C-o><Space>p

  nnoremap <silent> <Space>g :<C-u>Unite -buffer-name=search-buffer grep:.<CR>

  call dein#set_hook('unite.vim', 'hook_source', function('s:unite_on_source'))
endif


"=== Plugin: vim-altr
"==============================================================================================
if dein#tap('vim-altr')
  function! s:altr_on_source() abort
    " Header files
    call altr#define('%.c', '%.h', '%.m')

    " Rails / Ruby
    call altr#define('app/models/%.rb', 'spec/models/%_spec.rb', 'spec/factories/%s.rb')
    call altr#define('app/%/%.rb', 'spec/%/%_spec.rb')
    call altr#define('lib/%.rb', 'spec/lib/%_spec.rb')
    call altr#define('%.html.haml', '%_smart_phone.html.haml')
    call altr#define('%.html.slim', '%_smart_phone.html.slim')
    call altr#define('Gemfile', 'Gemfile.lock')

    " I18n
    call altr#define('locales/%/en.yml', 'locales/%/ja.yml')
    call altr#define('locales/%.en.yml', 'locales/%.ja.yml')
    call altr#define('locales/en.json', 'locales/ja.json')
    call altr#define('locales/%/en.json', 'locales/%/ja.json')

    " Frontend
    call altr#define('src/%.coffee', 'spec/%_spec.coffee', 'test/%_spec.coffee', 'test/%.coffee')
    call altr#define('%.js', '%.jsx', '%.coffee', '%.scss', '%.jade')

    " Golang
    call altr#define('%.go', '%_test.go', '%_ex_test.go')
    call altr#define('glide.yaml', 'glide.lock')

    " Dotenv
    call altr#define('.env', '.env.sample')

    " Vim
    call altr#define('dein.toml', 'dein_lazy.toml')
  endfunction

  nmap ga <Plug>(altr-forward)
  nmap gA <Plug>(altr-back)

  call dein#set_hook('vim-altr', 'hook_source', function('s:altr_on_source'))
endif


"=== Plugin: vim-quickrun
"==============================================================================================
if dein#tap('vim-quickrun')
  let g:quickrun_config = {}
  let g:quickrun_config['_'] = {
    \ 'runner':                        'vimproc',
    \ 'outputter/buffer/split':        ':botright 15sp',
    \ 'outputter/buffer/running_mark': '',
  \ }
  let g:quickrun_config['ruby.rspec'] = {
    \ 'type':    'ruby.rspec',
    \ 'command': 'rspec',
    \ 'cmdopt':  'bundle exec',
    \ 'exec':    '%o %c %s',
  \ }
  let g:quickrun_config['markdown'] = {
    \ 'outputter': 'null',
    \ 'command':   'open',
    \ 'cmdopt':    '-a',
    \ 'args':      'Marked',
    \ 'exec':      '%c %o %a %s',
  \ }
  let g:quickrun_config['javascript'] = {
    \ 'command': 'node',
  \ }
  let g:quickrun_config['coffee'] = {
    \ 'command': 'coffee',
    \ 'exec':    ['%c -cbp %s | node'],
  \ }
  let g:quickrun_config['swift'] = {
    \ 'command': 'xcrun',
    \ 'cmdopt':  'swift',
    \ 'exec':    '%c %o %s',
  \ }
  let g:quickrun_config['scala'] = {
    \ 'command': 'scala',
    \ 'cmdopt':  '-deprecation -feature',
    \ 'exec':    '%c %o %s %a',
  \ }

  nmap <Leader>r <Plug>(quickrun)
endif


"=== Plugin: neomake
"==============================================================================================
if dein#tap('neomake')
  let g:neomake_error_sign = {
    \ 'text':   '✗',
    \ 'texthl': 'NeomakeErrorSign',
  \ }
  let g:neomake_warning_sign = {
    \ 'text':   '∆',
    \ 'texthl': 'NeomakeWarningSign',
  \ }
  let g:neomake_message_sign = {
    \ 'text':   '▸',
    \ 'texthl': 'NeomakeMessageSign',
  \ }

  if dein#tap('candle.vim')
    call candle#highlight('NeomakeErrorSign', 'red', '', '')
    call candle#highlight('NeomakeWarningSign', 'yellow', '', '')
    call candle#highlight('NeomakeMessageSign', 'green', '', '')
  endif

  let g:neomake_ruby_mri_exe = $HOME . '/.anyenv/envs/rbenv/shims/ruby'

  autocmd vimrc User AutoSavePost Neomake
  autocmd vimrc BufEnter,BufReadPost,BufWritePost,InsertLeave * Neomake
endif


"=== Plugin: vim-submode
"==============================================================================================
if dein#tap('vim-submode')
  let g:submode_keep_leaving_key = 1

  "  Window resizing
  "-----------------------------------------------
  call submode#enter_with('winsize', 'n', '', '<C-w>>', '<C-w>>')
  call submode#map(       'winsize', 'n', '', '>',      '<C-w>>')
  call submode#enter_with('winsize', 'n', '', '<C-w><', '<C-w><')
  call submode#map(       'winsize', 'n', '', '<',      '<C-w><')
  call submode#enter_with('winsize', 'n', '', '<C-w>+', '<C-w>-')
  call submode#map(       'winsize', 'n', '', '-',      '<C-w>+')
  call submode#enter_with('winsize', 'n', '', '<C-w>-', '<C-w>+')
  call submode#map(       'winsize', 'n', '', '+',      '<C-w>-')


  "  Macro
  "-----------------------------------------------
  call submode#enter_with('macro', 'n', '', '@@', '@@')
  call submode#map(       'macro', 'n', '', '@',  '@@')


  "  Fold navigation
  "-----------------------------------------------
  call submode#enter_with('move-to-fold', 'n', '', 'zj', 'zj')
  call submode#map(       'move-to-fold', 'n', '', 'j',  'zj')
  call submode#enter_with('move-to-fold', 'n', '', 'zk', 'zk')
  call submode#map(       'move-to-fold', 'n', '', 'k',  'zk')


  "  Better undo
  "-----------------------------------------------
  function! s:better_undo(key)
    undojoin
    exec 'normal!' a:key
  endfunction

  noremap <silent> <Plug>(my-x) :<C-u>call <SID>better_undo('"_x')<CR>
  call submode#enter_with('my_x', 'n', '',  'x', '"_x')
  call submode#map(       'my_x', 'n', 'r', 'x', '<Plug>(my-x)')

  noremap <silent> <Plug>(my-ca) :<C-u>call <SID>better_undo('<C-a>')<CR>
  call submode#enter_with('my_ca', 'n', '',  '<C-a>', '<C-a>')
  call submode#map(       'my_ca', 'n', 'r', '<C-a>', '<Plug>(my-ca)')

  noremap <silent> <Plug>(my-cx) :<C-u>call <SID>better_undo('<C-x>')<CR>
  call submode#enter_with('my_ca', 'n', '',  '<C-x>', '<C-x>')
  call submode#map(       'my_ca', 'n', 'r', '<C-x>', '<Plug>(my-cx)')
endif


"=== Plugin: vim-tags
"==============================================================================================
if dein#tap('vim-tags')
  let g:vim_tags_auto_generate = 1
  let g:vim_tags_main_file = '.tags'
  let g:vim_tags_gems_tags_command = '{CTAGS} -R {OPTIONS} `rbenv exec bundle show --paths` 2>/dev/null'

  let g:vim_tags_directories = [
    \ '.git',
    \ '.hg',
    \ '.svn',
    \ '.vimprojectroot',
    \ '.bzr',
    \ '_darcs',
    \ 'CVS',
  \ ]

  nnoremap tg :TagsGenerate<CR>
endif


"=== Plugin: vim-signature
"==============================================================================================
if dein#tap('vim-signature')
  " hide upper case marks
  let g:SignatureIncludeMarks = 'abcdefghijklmnopqrstuvwxyz'
endif


"=== Plugin: vim-anzu
"==============================================================================================
if dein#tap('vim-anzu')
  nmap n <Plug>(anzu-n-with-echo)
  nmap N <Plug>(anzu-N-with-echo)
  nmap * <Plug>(anzu-star-with-echo)
  nmap # <Plug>(anzu-sharp-with-echo)
endif


"=== Plugin: vim-rails
"==============================================================================================
if dein#tap('vim-rails')
  nmap gr :R<CR>
endif


"=== Plugin: vim-scala
"==============================================================================================
if dein#tap('vim-scala')
  let g:scala_sort_across_groups = 1
endif


"=== Plugin: vim-go-extra
"==============================================================================================
if dein#tap('vim-go-extra')
  let g:gocomplete#system_function = 'vimproc#system2'
endif


"=== Plugin: typescript-tools
"==============================================================================================
if dein#tap('typescript-tools.vim')
  " let g:TSS = ['bin/tss']
endif


" ---------------------------------------------------------------------------------------------
"                                             END
" ---------------------------------------------------------------------------------------------
doautocmd User VimrcHookPost
