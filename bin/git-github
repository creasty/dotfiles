#!/usr/bin/env bash

source "$(dirname $0)/../lib/helpers.sh"


REPO="$(
  git config --get remote.origin.url \
    | grep github.com \
    | sed 's/^.*github\.com[:\/]\(.*\)\.git$/\1/' \
    | tr -d "\n"
)"

if [ -z "$REPO" ]; then
  [ -t 1 ] && print_error 'Remote origin is not at github.com'
  exit 1
fi

DEFAULT_PAR_PAGE=100

USERNAME="${REPO%%/*}"
HEAD="$(git symbolic-ref --short HEAD)"
PROJECT_DIR="$(git rev-parse --show-toplevel)"
GIT_DIR="$PROJECT_DIR/.git"


#  Functions
#-----------------------------------------------
client() {
  cat | curl "https://api.github.com/$2" \
    -sS \
    -X "$1" \
    -H 'Accept: application/vnd.github.v3+json' \
    -H "Authorization: token $GITHUB_ACCESS_TOKEN" \
    -d @-
}

editor() {
  if [ -z "${GIT_EDITOR:+set}" ]; then
    GIT_EDITOR="$(git var GIT_EDITOR)" || return $?
  fi

  eval "$GIT_EDITOR" '"$@"'
}


#  Commands
#-----------------------------------------------
command_ls_issue() {
  local ruby='
    JSON.parse($stdin.read).each do |issue|
      next if issue["pull_request"]
      puts "#%d %s" % [issue["number"], issue["title"]]
    end
  '

  local page="${1:-$DEFAULT_PAR_PAGE}"

  echo \
    | client GET "repos/$REPO/issues?per_page=$page" \
    | ruby -r json -e "$ruby"
}

command_ls_pr() {
  local ruby='
    JSON.parse($stdin.read).each do |issue|
      puts "#%d %s" % [issue["number"], issue["title"]]
    end
  '

  local page="${1:-$DEFAULT_PAR_PAGE}"

  echo \
    | client GET "repos/$REPO/pulls?per_page=$page" \
    | ruby -r json -e "$ruby"
}

command_mk_pr() {
  local ruby_in='
    head, base = ARGV
    data = $stdin.read.gsub(/\n?\r/, "\n").split /\n{2}/
    title = data.shift
    body = data.join("\n\n").gsub /\A\s+|\s+\z/, ""

    unless title =~ /^\s*$/
      data = {
        title: title,
        body:  body,
        head:  head,
        base:  base,
      }
      puts data.to_json
    end
  '

  local ruby_out='
    res = JSON.parse $stdin.read
    puts res["html_url"] || res["message"]
  '

  local head="${1:-$HEAD}"
  local base="${2:-master}"

  local last_commit="$(git log -n 1 --pretty=format:'%s' "${base}..${head}" | cat)"

  if [ -z "$last_commit" ]; then
    [ -t 1 ] && print_error 'No commits'
    exit 1
  fi

  local file="$GIT_DIR/PR_EDITMSG.markdown"
  echo -e "$last_commit\n\n## What\n\n" > "$file"

  editor "$file"

  [ -t 1 ] && section "Creating a pull request to $base from $head"

  ruby -r json -e "$ruby_in" "$head" "$base" < "$file" \
    | client POST "repos/$REPO/pulls" \
    | ruby -r json -e "$ruby_out" \
    | tr -d "\n" \
    | {
      res="$(cat)"

      case "$res" in
        http*)
          if [ -t 1 ]; then
            print_success "$res"
            echo -n "$res" | pbcopy
          else
            echo "$res"
          fi
          ;;

        *)
          [ -t 1 ] && print_error "${res:-"Couldn't create pull request"}"
          exit 1
          ;;
      esac
    }
}


#  Dispatch
#-----------------------------------------------
COMMAND="$1"
shift

case "$COMMAND" in
  repo)
    echo "$REPO"
    ;;

  username)
    echo "$USERNAME"
    ;;

  url)
    echo "https://github.com/$REPO"
    ;;

  ls-issue)
    command_ls_issue "$1"
    ;;

  ls-pr)
    command_ls_pr "$1"
    ;;

  mk-pr)
    command_mk_pr "$1" "$2"
    ;;

  *)
    [ -t 1 ] && print_error 'Command not found'
    exit 1
    ;;
esac
